{"version":3,"sources":["/node_modules/redux-persist/src/constants.js","/node_modules/redux-persist/node_modules/lodash-es/_objectToString.js","/node_modules/redux-persist/node_modules/lodash-es/_baseGetTag.js","/node_modules/redux-persist/node_modules/lodash-es/_getRawTag.js","/node_modules/redux-persist/node_modules/lodash-es/_overArg.js","/node_modules/redux-persist/node_modules/lodash-es/_getPrototype.js","/node_modules/redux-persist/node_modules/lodash-es/isObjectLike.js","/node_modules/redux-persist/node_modules/lodash-es/isPlainObject.js","/node_modules/redux-persist/src/utils/isStatePlainEnough.js","/node_modules/redux-persist/src/autoRehydrate.js","/node_modules/redux-persist/src/utils/setImmediate.js","/node_modules/redux-persist/src/defaults/asyncLocalStorage.js","/node_modules/redux-persist/src/purgeStoredState.js","/node_modules/redux-persist/node_modules/json-stringify-safe/stringify.js","/node_modules/redux-persist/src/createPersistor.js","/node_modules/redux-persist/src/createTransform.js","/node_modules/redux-persist/src/getStoredState.js","/node_modules/redux-persist/src/persistStore.js","/node_modules/redux-persist/src/index.js"],"names":["REHYDRATE","exports","module","f","define","amd","g","window","global","self","this","PIXI","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","v","c","nativeObjectToString","hasOwnProperty","objectProto","symToStringTag","mask","max","x","y","isPow2","log2","shift","log10","prevPow2","REVERSE_TABLE","Array","deinterleave3","nextCombination","triangles","config","signedArea","data","start","end","dim","store","liftReducer","reducer","rehydrated","preRehydrateActions","action","again","equals","p","next","area","prev","reducedState","inboundState","state","logPreRehydrate","newState","minY","size","babelHelpers.typeof","console","push","log","isStatePlainEnough","hasNativeSupport","setImmediate","ear","cureLocalIntersections","earcutLinked","minX","pass","error","filterPoints","storage","testKey","getItem","warn","pointInTriangle","b","_hasStorage","getStorage","hasLocalStorage","hasSessionStorage","sessionStorage","noStorage","zOrder","minTX","minTY","maxTX","maxTY","cb","keys","z","minZ","key","Promise","resolve","reject","prevZ","intersects","locallyInside","setItem","string","removeNode","isValidDiagonal","splitPolygon","purgeStoredState","isArray","getAllKeys","eliminateHoles","holeIndices","outerNode","indexOf","keyPrefix","len","list","linkedList","steiner","queue","getLeftmost","warnIfRemoveError","hole","findHoleBridge","m","hy","qx","Infinity","hx","createPersistor","serializer","defaultSerializer","transforms","debounce","stateIterator","stateSetter","Math","timeIterator","paused","subState","passWhitelistBlacklist","storesToProcess","nextZ","storageKey","endState","reduce","qSize","transformer","whitelist","blacklist","inSize","incoming","deserializer","value","q","rehydrateAction","createStorageKey","adhocRehydrate","tail","numMerges","stringify","defaultDeserializer","serial","JSON","parse","defaultStateIterator","collection","Object","callback","defaultStateSetter","ay","py","bx","cy","cx","px","by","createTransform","inbound","intersectsPolygon","whitelistBlacklistCheck","p1","p2","q2","q1","serialize","completionCount","allKeys","err","persistKeys","map","slice","keysToRestore","filter","restoreCount","a2","Node","rehydrate","complete","last","onComplete","shouldRestore","process","sum","j","restoredState","persistor","purge","payload","abs","trianglesArea","polygonArea","flatten","cb3","result","vertices","holes","dimensions","deprecatedStorage","d"],"mappings":"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","file":"vendor-bundle-59ba32148e.js","sourceRoot":"..","sourcesContent":["export const KEY_PREFIX = 'reduxPersist:'\nexport const REHYDRATE = 'persist/REHYDRATE'\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nexport default objectToString;\n","import Symbol from './_Symbol.js';\nimport getRawTag from './_getRawTag.js';\nimport objectToString from './_objectToString.js';\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nexport default baseGetTag;\n","import Symbol from './_Symbol.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nexport default getRawTag;\n","/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\nexport default overArg;\n","import overArg from './_overArg.js';\n\n/** Built-in value references. */\nvar getPrototype = overArg(Object.getPrototypeOf, Object);\n\nexport default getPrototype;\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nexport default isObjectLike;\n","import baseGetTag from './_baseGetTag.js';\nimport getPrototype from './_getPrototype.js';\nimport isObjectLike from './isObjectLike.js';\n\n/** `Object#toString` result references. */\nvar objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to infer the `Object` constructor. */\nvar objectCtorString = funcToString.call(Object);\n\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */\nfunction isPlainObject(value) {\n  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n    return false;\n  }\n  var proto = getPrototype(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n  return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n    funcToString.call(Ctor) == objectCtorString;\n}\n\nexport default isPlainObject;\n","import isPlainObject from 'lodash/isPlainObject'\n\nexport default function isStatePlainEnough (a) {\n  // isPlainObject + duck type not immutable\n  if (!a) return false\n  if (typeof a !== 'object') return false\n  if (typeof a.asMutable === 'function') return false\n  if (!isPlainObject(a)) return false\n  return true\n}\n","import { REHYDRATE } from './constants'\nimport isStatePlainEnough from './utils/isStatePlainEnough'\n\nexport default function autoRehydrate (config = {}) {\n  const stateReconciler = config.stateReconciler || defaultStateReconciler\n\n  return (next) => (reducer, initialState, enhancer) => {\n    let store = next(liftReducer(reducer), initialState, enhancer)\n    return {\n      ...store,\n      replaceReducer: (reducer) => {\n        return store.replaceReducer(liftReducer(reducer))\n      }\n    }\n  }\n\n  function liftReducer (reducer) {\n    let rehydrated = false\n    let preRehydrateActions = []\n    return (state, action) => {\n      if (action.type !== REHYDRATE) {\n        if (config.log && !rehydrated) preRehydrateActions.push(action) // store pre-rehydrate actions for debugging\n        return reducer(state, action)\n      } else {\n        if (config.log && !rehydrated) logPreRehydrate(preRehydrateActions)\n        rehydrated = true\n\n        let inboundState = action.payload\n        let reducedState = reducer(state, action)\n\n        return stateReconciler(state, inboundState, reducedState, config.log)\n      }\n    }\n  }\n}\n\nfunction logPreRehydrate (preRehydrateActions) {\n  const concernedActions = preRehydrateActions.slice(1)\n  if (concernedActions.length > 0) {\n    console.log(`\n      redux-persist/autoRehydrate: %d actions were fired before rehydration completed. This can be a symptom of a race\n      condition where the rehydrate action may overwrite the previously affected state. Consider running these actions\n      after rehydration:\n    `, concernedActions.length, concernedActions)\n  }\n}\n\nfunction defaultStateReconciler (state, inboundState, reducedState, log) {\n  let newState = {...reducedState}\n\n  Object.keys(inboundState).forEach((key) => {\n    // if initialState does not have key, skip auto rehydration\n    if (!state.hasOwnProperty(key)) return\n\n    // if initial state is an object but inbound state is null/undefined, skip\n    if (typeof state[key] === 'object' && !inboundState[key]) {\n      if (log) console.log('redux-persist/autoRehydrate: sub state for key `%s` is falsy but initial state is an object, skipping autoRehydrate.', key)\n      return\n    }\n\n    // if reducer modifies substate, skip auto rehydration\n    if (state[key] !== reducedState[key]) {\n      if (log) console.log('redux-persist/autoRehydrate: sub state for key `%s` modified, skipping autoRehydrate.', key)\n      newState[key] = reducedState[key]\n      return\n    }\n\n    // otherwise take the inboundState\n    if (isStatePlainEnough(inboundState[key]) && isStatePlainEnough(state[key])) newState[key] = {...state[key], ...inboundState[key]} // shallow merge\n    else newState[key] = inboundState[key] // hard set\n\n    if (log) console.log('redux-persist/autoRehydrate: key `%s`, rehydrated to ', key, newState[key])\n  })\n  return newState\n}\n","const hasNativeSupport = typeof global !== 'undefined' && typeof global.setImmediate !== 'undefined'\nconst setImmediate = hasNativeSupport ? (fn, ms) => global.setImmediate(fn, ms) : (fn, ms) => setTimeout(fn, ms)\n\nexport default setImmediate\n","import setImmediate from '../utils/setImmediate'\n\nlet noStorage = () => { /* noop */ return null }\nif (process.env.NODE_ENV !== 'production') {\n  noStorage = () => {\n    console.error('redux-persist asyncLocalStorage requires a global localStorage object. Either use a different storage backend or if this is a universal redux application you probably should conditionally persist like so: https://gist.github.com/rt2zz/ac9eb396793f95ff3c3b')\n    return null\n  }\n}\n\nfunction _hasStorage (storageType) {\n  if (typeof window !== 'object' || !(storageType in window)) {\n    return false\n  }\n\n  try {\n    let storage = window[storageType]\n    const testKey = `redux-persist ${storageType} test`\n    storage.setItem(testKey, 'test')\n    storage.getItem(testKey)\n    storage.removeItem(testKey)\n  } catch (e) {\n    if (process.env.NODE_ENV !== 'production') console.warn(`redux-persist ${storageType} test failed, persistence will be disabled.`)\n    return false\n  }\n  return true\n}\n\nfunction hasLocalStorage () {\n  return _hasStorage('localStorage')\n}\n\nfunction hasSessionStorage () {\n  return _hasStorage('sessionStorage')\n}\n\nfunction getStorage (type) {\n  if (type === 'local') {\n    return hasLocalStorage()\n      ? window.localStorage\n      : { getItem: noStorage, setItem: noStorage, removeItem: noStorage, getAllKeys: noStorage }\n  }\n  if (type === 'session') {\n    return hasSessionStorage()\n      ? window.sessionStorage\n      : { getItem: noStorage, setItem: noStorage, removeItem: noStorage, getAllKeys: noStorage }\n  }\n}\n\nexport default function (type, config) {\n  let storage = getStorage(type)\n  return {\n    getAllKeys: function (cb) {\n      return new Promise((resolve, reject) => {\n        try {\n          var keys = []\n          for (var i = 0; i < storage.length; i++) {\n            keys.push(storage.key(i))\n          }\n          setImmediate(() => {\n            cb && cb(null, keys)\n            resolve(keys)\n          })\n        } catch (e) {\n          cb && cb(e)\n          reject(e)\n        }\n      })\n    },\n    getItem (key, cb) {\n      return new Promise((resolve, reject) => {\n        try {\n          var s = storage.getItem(key)\n          setImmediate(() => {\n            cb && cb(null, s)\n            resolve(s)\n          })\n        } catch (e) {\n          cb && cb(e)\n          reject(e)\n        }\n      })\n    },\n    setItem (key, string, cb) {\n      return new Promise((resolve, reject) => {\n        try {\n          storage.setItem(key, string)\n          setImmediate(() => {\n            cb && cb(null)\n            resolve()\n          })\n        } catch (e) {\n          cb && cb(e)\n          reject(e)\n        }\n      })\n    },\n    removeItem (key, cb) {\n      return new Promise((resolve, reject) => {\n        try {\n          storage.removeItem(key)\n          setImmediate(() => {\n            cb && cb(null)\n            resolve()\n          })\n        } catch (e) {\n          cb && cb(e)\n          reject(e)\n        }\n      })\n    }\n  }\n}\n","import { KEY_PREFIX } from './constants'\n\nexport default function purgeStoredState (config, keys) {\n  const storage = config.storage\n  const keyPrefix = config.keyPrefix !== undefined ? config.keyPrefix : KEY_PREFIX\n\n  // basic validation\n  if (Array.isArray(config)) throw new Error('redux-persist: purgeStoredState requires config as a first argument (found array). An array of keys is the optional second argument.')\n  if (!storage) throw new Error('redux-persist: config.storage required in purgeStoredState')\n\n  if (typeof keys === 'undefined') { // if keys is not defined, purge all keys\n    return new Promise((resolve, reject) => {\n      storage.getAllKeys((err, allKeys) => {\n        if (err) {\n          if (process.env.NODE_ENV !== 'production') console.warn('redux-persist: error during purgeStoredState in storage.getAllKeys')\n          reject(err)\n        } else {\n          resolve(purgeStoredState(config, allKeys.filter((key) => key.indexOf(keyPrefix) === 0).map((key) => key.slice(keyPrefix.length))))\n        }\n      })\n    })\n  } else { // otherwise purge specified keys\n    return Promise.all(keys.map((key) => {\n      return storage.removeItem(`${keyPrefix}${key}`, warnIfRemoveError(key))\n    }))\n  }\n}\n\nfunction warnIfRemoveError (key) {\n  return function removeError (err) {\n    if (err && process.env.NODE_ENV !== 'production') { console.warn('Error storing data for key:', key, err) }\n  }\n}\n","exports = module.exports = stringify\nexports.getSerialize = serializer\n\nfunction stringify(obj, replacer, spaces, cycleReplacer) {\n  return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces)\n}\n\nfunction serializer(replacer, cycleReplacer) {\n  var stack = [], keys = []\n\n  if (cycleReplacer == null) cycleReplacer = function(key, value) {\n    if (stack[0] === value) return \"[Circular ~]\"\n    return \"[Circular ~.\" + keys.slice(0, stack.indexOf(value)).join(\".\") + \"]\"\n  }\n\n  return function(key, value) {\n    if (stack.length > 0) {\n      var thisPos = stack.indexOf(this)\n      ~thisPos ? stack.splice(thisPos + 1) : stack.push(this)\n      ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key)\n      if (~stack.indexOf(value)) value = cycleReplacer.call(this, key, value)\n    }\n    else stack.push(value)\n\n    return replacer == null ? value : replacer.call(this, key, value)\n  }\n}\n","import { KEY_PREFIX, REHYDRATE } from './constants'\nimport createAsyncLocalStorage from './defaults/asyncLocalStorage'\nimport purgeStoredState from './purgeStoredState'\nimport stringify from 'json-stringify-safe'\n\nexport default function createPersistor (store, config) {\n  // defaults\n  const serializer = config.serialize === false ? (data) => data : defaultSerializer\n  const deserializer = config.serialize === false ? (data) => data : defaultDeserializer\n  const blacklist = config.blacklist || []\n  const whitelist = config.whitelist || false\n  const transforms = config.transforms || []\n  const debounce = config.debounce || false\n  const keyPrefix = config.keyPrefix !== undefined ? config.keyPrefix : KEY_PREFIX\n\n  // pluggable state shape (e.g. immutablejs)\n  const stateInit = config._stateInit || {}\n  const stateIterator = config._stateIterator || defaultStateIterator\n  const stateGetter = config._stateGetter || defaultStateGetter\n  const stateSetter = config._stateSetter || defaultStateSetter\n\n  // storage with keys -> getAllKeys for localForage support\n  let storage = config.storage || createAsyncLocalStorage('local')\n  if (storage.keys && !storage.getAllKeys) {\n    storage.getAllKeys = storage.keys\n  }\n\n  // initialize stateful values\n  let lastState = stateInit\n  let paused = false\n  let storesToProcess = []\n  let timeIterator = null\n\n  store.subscribe(() => {\n    if (paused) return\n\n    let state = store.getState()\n\n    stateIterator(state, (subState, key) => {\n      if (!passWhitelistBlacklist(key)) return\n      if (stateGetter(lastState, key) === stateGetter(state, key)) return\n      if (storesToProcess.indexOf(key) !== -1) return\n      storesToProcess.push(key)\n    })\n\n    // time iterator (read: debounce)\n    if (timeIterator === null) {\n      timeIterator = setInterval(() => {\n        if (storesToProcess.length === 0) {\n          clearInterval(timeIterator)\n          timeIterator = null\n          return\n        }\n\n        let key = storesToProcess.shift()\n        let storageKey = createStorageKey(key)\n        let endState = transforms.reduce((subState, transformer) => transformer.in(subState, key), stateGetter(store.getState(), key))\n        if (typeof endState !== 'undefined') storage.setItem(storageKey, serializer(endState), warnIfSetError(key))\n      }, debounce)\n    }\n\n    lastState = state\n  })\n\n  function passWhitelistBlacklist (key) {\n    if (whitelist && whitelist.indexOf(key) === -1) return false\n    if (blacklist.indexOf(key) !== -1) return false\n    return true\n  }\n\n  function adhocRehydrate (incoming, options = {}) {\n    let state = {}\n    if (options.serial) {\n      stateIterator(incoming, (subState, key) => {\n        try {\n          let data = deserializer(subState)\n          let value = transforms.reduceRight((interState, transformer) => {\n            return transformer.out(interState, key)\n          }, data)\n          state = stateSetter(state, key, value)\n        } catch (err) {\n          if (process.env.NODE_ENV !== 'production') console.warn(`Error rehydrating data for key \"${key}\"`, subState, err)\n        }\n      })\n    } else state = incoming\n\n    store.dispatch(rehydrateAction(state))\n    return state\n  }\n\n  function createStorageKey (key) {\n    return `${keyPrefix}${key}`\n  }\n\n  // return `persistor`\n  return {\n    rehydrate: adhocRehydrate,\n    pause: () => { paused = true },\n    resume: () => { paused = false },\n    purge: (keys) => purgeStoredState({storage, keyPrefix}, keys)\n  }\n}\n\nfunction warnIfSetError (key) {\n  return function setError (err) {\n    if (err && process.env.NODE_ENV !== 'production') { console.warn('Error storing data for key:', key, err) }\n  }\n}\n\nfunction defaultSerializer (data) {\n  return stringify(data, null, null, (k, v) => {\n    if (process.env.NODE_ENV !== 'production') return null\n    throw new Error(`\n      redux-persist: cannot process cyclical state.\n      Consider changing your state structure to have no cycles.\n      Alternatively blacklist the corresponding reducer key.\n      Cycle encounted at key \"${k}\" with value \"${v}\".\n    `)\n  })\n}\n\nfunction defaultDeserializer (serial) {\n  return JSON.parse(serial)\n}\n\nfunction rehydrateAction (data) {\n  return {\n    type: REHYDRATE,\n    payload: data\n  }\n}\n\nfunction defaultStateIterator (collection, callback) {\n  return Object.keys(collection).forEach((key) => callback(collection[key], key))\n}\n\nfunction defaultStateGetter (state, key) {\n  return state[key]\n}\n\nfunction defaultStateSetter (state, key, value) {\n  state[key] = value\n  return state\n}\n","function createTransform (inbound, outbound, config = {}) {\n  let whitelist = config.whitelist || null\n  let blacklist = config.blacklist || null\n\n  function whitelistBlacklistCheck (key) {\n    if (whitelist && whitelist.indexOf(key) === -1) return true\n    if (blacklist && blacklist.indexOf(key) !== -1) return true\n    return false\n  }\n\n  return {\n    in: (state, key) => !whitelistBlacklistCheck(key) && inbound ? inbound(state, key) : state,\n    out: (state, key) => !whitelistBlacklistCheck(key) && outbound ? outbound(state, key) : state\n  }\n}\n\nexport default createTransform\n","import { KEY_PREFIX } from './constants'\nimport createAsyncLocalStorage from './defaults/asyncLocalStorage'\n\nexport default function getStoredState (config, onComplete) {\n  let storage = config.storage || createAsyncLocalStorage('local')\n  const deserializer = config.serialize === false ? (data) => data : defaultDeserializer\n  const blacklist = config.blacklist || []\n  const whitelist = config.whitelist || false\n  const transforms = config.transforms || []\n  const keyPrefix = config.keyPrefix !== undefined ? config.keyPrefix : KEY_PREFIX\n\n  // fallback getAllKeys to `keys` if present (LocalForage compatability)\n  if (storage.keys && !storage.getAllKeys) storage = {...storage, getAllKeys: storage.keys}\n\n  let restoredState = {}\n  let completionCount = 0\n\n  storage.getAllKeys((err, allKeys) => {\n    if (err) {\n      if (process.env.NODE_ENV !== 'production') console.warn('redux-persist/getStoredState: Error in storage.getAllKeys')\n      complete(err)\n    }\n\n    let persistKeys = allKeys.filter((key) => key.indexOf(keyPrefix) === 0).map((key) => key.slice(keyPrefix.length))\n    let keysToRestore = persistKeys.filter(passWhitelistBlacklist)\n\n    let restoreCount = keysToRestore.length\n    if (restoreCount === 0) complete(null, restoredState)\n    keysToRestore.forEach((key) => {\n      storage.getItem(createStorageKey(key), (err, serialized) => {\n        if (err && process.env.NODE_ENV !== 'production') console.warn('redux-persist/getStoredState: Error restoring data for key:', key, err)\n        else restoredState[key] = rehydrate(key, serialized)\n        completionCount += 1\n        if (completionCount === restoreCount) complete(null, restoredState)\n      })\n    })\n  })\n\n  function rehydrate (key, serialized) {\n    let state = null\n\n    try {\n      let data = deserializer(serialized)\n      state = transforms.reduceRight((subState, transformer) => {\n        return transformer.out(subState, key)\n      }, data)\n    } catch (err) {\n      if (process.env.NODE_ENV !== 'production') console.warn('redux-persist/getStoredState: Error restoring data for key:', key, err)\n    }\n\n    return state\n  }\n\n  function complete (err, restoredState) {\n    onComplete(err, restoredState)\n  }\n\n  function passWhitelistBlacklist (key) {\n    if (whitelist && whitelist.indexOf(key) === -1) return false\n    if (blacklist.indexOf(key) !== -1) return false\n    return true\n  }\n\n  function createStorageKey (key) {\n    return `${keyPrefix}${key}`\n  }\n\n  if (typeof onComplete !== 'function' && !!Promise) {\n    return new Promise((resolve, reject) => {\n      onComplete = (err, restoredState) => {\n        if (err) reject(err)\n        else resolve(restoredState)\n      }\n    })\n  }\n}\n\nfunction defaultDeserializer (serial) {\n  return JSON.parse(serial)\n}\n","import { REHYDRATE } from './constants'\nimport getStoredState from './getStoredState'\nimport createPersistor from './createPersistor'\nimport setImmediate from './utils/setImmediate'\n\nexport default function persistStore (store, config = {}, onComplete) {\n  // defaults\n  // @TODO remove shouldRestore\n  const shouldRestore = !config.skipRestore\n  if (process.env.NODE_ENV !== 'production' && config.skipRestore) console.warn('redux-persist: config.skipRestore has been deprecated. If you want to skip restoration use `createPersistor` instead')\n\n  let purgeKeys = null\n\n  // create and pause persistor\n  const persistor = createPersistor(store, config)\n  persistor.pause()\n\n  // restore\n  if (shouldRestore) {\n    setImmediate(() => {\n      getStoredState(config, (err, restoredState) => {\n        if (err) {\n          complete(err)\n          return\n        }\n        // do not persist state for purgeKeys\n        if (purgeKeys) {\n          if (purgeKeys === '*') restoredState = {}\n          else purgeKeys.forEach((key) => delete restoredState[key])\n        }\n\n        store.dispatch(rehydrateAction(restoredState, err))\n        complete(err, restoredState)\n      })\n    })\n  } else setImmediate(complete)\n\n  function complete (err, restoredState) {\n    persistor.resume()\n    onComplete && onComplete(err, restoredState)\n  }\n\n  return {\n    ...persistor,\n    purge: (keys) => {\n      purgeKeys = keys || '*'\n      return persistor.purge(keys)\n    }\n  }\n}\n\nfunction rehydrateAction (payload, error = null) {\n  return {\n    type: REHYDRATE,\n    payload,\n    error\n  }\n}\n","import autoRehydrate from './autoRehydrate'\nimport createPersistor from './createPersistor'\nimport createTransform from './createTransform'\nimport getStoredState from './getStoredState'\nimport persistStore from './persistStore'\nimport purgeStoredState from './purgeStoredState'\n\n// @TODO remove in v5\nconst deprecated = (cb, cb2, cb3) => {\n  console.error('redux-persist: this method of importing storages has been removed. instead use `import { asyncLocalStorage } from \"redux-persist/storages\"`')\n  if (typeof cb === 'function') cb()\n  if (typeof cb2 === 'function') cb2()\n  if (typeof cb3 === 'function') cb3()\n}\nconst deprecatedStorage = { getAllKeys: deprecated, getItem: deprecated, setItem: deprecated, removeItem: deprecated }\nconst storages = {\n  asyncLocalStorage: deprecatedStorage,\n  asyncSessionStorage: deprecatedStorage\n}\n\nexport { autoRehydrate, createPersistor, createTransform, getStoredState, persistStore, purgeStoredState, storages }\n"]}