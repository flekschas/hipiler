{"version":3,"sources":["/node_modules/redux-persist/node_modules/lodash-es/_getRawTag.js","/node_modules/redux-persist/node_modules/lodash-es/_baseGetTag.js","/node_modules/redux-persist/node_modules/lodash-es/_overArg.js","/node_modules/redux-persist/node_modules/lodash-es/_objectToString.js","/node_modules/redux-persist/node_modules/lodash-es/isObjectLike.js","/node_modules/redux-persist/node_modules/lodash-es/_getPrototype.js","/node_modules/redux-persist/node_modules/lodash-es/isPlainObject.js","/node_modules/redux-persist/src/utils/isStatePlainEnough.js","/node_modules/redux-persist/src/autoRehydrate.js","/node_modules/redux-persist/src/utils/setImmediate.js","/node_modules/redux-persist/src/defaults/asyncLocalStorage.js","/node_modules/redux-persist/src/purgeStoredState.js","/node_modules/redux-persist/src/createPersistor.js","/node_modules/redux-persist/node_modules/json-stringify-safe/stringify.js","/node_modules/redux-persist/src/getStoredState.js","/node_modules/redux-persist/src/persistStore.js","/node_modules/redux-persist/src/index.js","/node_modules/redux-persist/src/createTransform.js"],"names":["self","this","drainQueues","hasOwnProperty","_drainQueues","_schedule","schedule","AsyncInvokeLater","fn","receiver","arg","_lateQueue","push","_normalQueue","_pushOne","promise","_queueTick","Error","objectProto","e","symToStringTag","prototype","setScheduler","_customScheduler","prev","hasCustomScheduler","enableTrampoline","Async","nativeObjectToString","process","exit","throwLater","Symbol","util","hasDevTools","invokeLater","AsyncSettlePromises","call","invoke","AsyncInvoke","settlePromises","_drainQueue","queue","_reject","targetRejected","context","promiseRejectionQueued","bindingPromise","_then","rejectThis","bindingResolved","thisArg","_bitField","_resolveCallback","target","_isBound","value","store","liftReducer","reducer","initialState","Promise","old","exports","bluebird","rehydrated","PromiseArray","apiRejection","debug","preRehydrateActions","tryCatch","action","type","config","log","cancel","logPreRehydrate","inboundState","reducedState","state","stateReconciler","concernedActions","_cancellationParent","parent","_isCancellable","defaultStateReconciler","_enoughBranchesHaveCancelled","isStatePlainEnough","console","setImmediate","_cancelBranched","_cancel","window","testKey","setItem","_settlePromises","_unsetOnCancel","_onCancelField","undefined","_hasStorage","onCancelCallback","internalOnly","getStorage","i","hasLocalStorage","hasSessionStorage","sessionStorage","getItem","_resultCancelled","_doInvokeOnCancel","_invokeInternalOnCancel","_onCancel","resolve","5","_dereq_","module","cb","NEXT_FILTER","_boundValue","instances","length","item","boundTo","matchesPredicate","removeItem","isObject","j","keys","key","predicateLoop","errorObj","storage","./util","Context","CapturedTrace","peekContext","createContext","_promiseCreated","warn","err","_peekContext","_pushContext","_trace","contextStack","warnIfRemoveError","create","deactivateLongStackTraces","Promise_pushContext","Promise_popContext","_popContext","Promise_peekContext","Promise_promiseCreated","Promise_PeekContext","longStackTraces","ctx","deserializer","serialize","name","persistor","cancellationExecute","executor","cb3","deprecatedStorage","storages","reject","onCancel","toString","_getDomain","async","defaultDeserializer","blacklist","Warning","whitelist","transforms","stateSetter","createAsyncLocalStorage","stateInit","env","timeIterator","passWhitelistBlacklist","storesToProcess","unhandledRejectionHandled","shift","transformer","getState","stateGetter","_settledValue","_setUnhandledRejectionIsNotified","possiblyUnhandledRejection","reason","_isUnhandledRejectionNotified","data","subState","_setRejectionIsUnhandled","dispatch","createStorageKey","keyPrefix","message","shouldUseOwnTrace","domain","getDomain","domainBind","onUnhandledRejectionHandled","warnIfSetError","disableLongStackTraces","defaultSerializer","longStackTracesIsSupported","Promise_captureStackTrace","_captureStackTrace","Promise_attachExtraTrace","_attachExtraTrace","parse","serial","rehydrateAction","REHYDRATE","defaultStateIterator","Object","defaultStateGetter","event","CustomEvent","createTransform","inbound","outbound","toLowerCase","detail","dispatchEvent","domEvent","whitelistBlacklistCheck","indexOf","global","getStoredState","onComplete","restoredState","completionCount","emit","apply","arguments","persistKeys","allKeys","method","methodName","slice","keysToRestore","generatePromiseLifecycleEventObject","promiseFulfilled","child","reduceRight","domEventFired","globalEventFired","JSON","opts","warningsOption","purgeKeys","wForgottenReturn","cancellation","shouldRestore","_propagateFrom","cancellationPropagateFrom","_fireEvent","activeFireEvent","monitoring","defaultFireEvent","_setOnCancel","handler","flags"],"mappings":"ggQAyBA,IAAAA,GAASC,IACPA,MAAIC,YAAQC,WACRH,EAAMI,gBAEVH,KAAII,UAAAC,UCLAC,GAAoBC,EAAEC,EAAAC,GAC3BT,KAAAU,WAAAC,KAAAJ,EAAAC,EAAAC,qGCjBDT,KAASY,aAAYC,SAAEC,GACrBd,KAAOe,kBFIT,KAAI,KAAA,IAAAC,OAAoB,MAAGC,GAAAA,EAAqBC,uCAG5CC,EAAAA,EAAAA,YAgBAC,UAAYC,aAAA,SAAAd,uBAIZ,OAFFP,MAAII,UAASG,EACbP,KAAIsB,kBAAU,EACRC,KAGFH,UAAOI,mBAAsB,iBAC9BxB,MAAAsB,oBAGJF,UAAAK,iBAAA,wIGnCDC,EAAIC,UAAAA,gBAAuBV,wKAS3BW,QAASC,KAAA,IAER7B,KAAA8B,WAAAZ,MFbGE,UAAYU,WAAG,SAAAvB,EAAqBE,iCAGpCF,EAAA,WAAiBwB,KAASA,6GAUxB,MAAKb,GACP,KAAO,IAAKF,OAAK,oECRpBgB,EAAAC,aEZDP,EAAAN,UAAAc,YAAA,SAAA3B,EAAAC,EAAAC,ySAwBS0B,EAAoBC,KAAApC,KAAAc,GAE5Bd,KAAAI,UAAA,8DCxBDsB,EAAAN,UAAAiB,OAAAC,EACIZ,EAAAN,UAAemB,eAAeJ,KCM9Bf,UAAWoB,YAAU,SAAUC,sCAG/B,IAAe,kBAAAlC,GAAf,4BAMAA,GAAA6B,KAAA5B,EAAmBC,0fA8BvBT,KAAS0C,QAAAxB,IAGNyB,EAAA,SAAAzB,EAAA0B,GACDA,EAASC,wBAAuB,EAChCD,EAASE,eAAWC,MAAAC,EAAAA,EAAA,KAAAhD,KAAAkB,IAGpB+B,EAAW,SAAeC,EAAYN,GACF,IAAd,SAAf5C,KAAAmD,YACLnD,KAAAoD,iBAAuBR,EAAIS,qnBCtD7BjC,UAAekC,SAAP,iBACJ,WAAA,QAAAtD,KAAAmD,mBAGJ,SAAAD,EAAAK,uFCDMC,UAAaC,IAAYC,QAAUC,2BADlC,oBAAAC,WAAAC,EAAAD,iDAAAE,QAAAC,+DAWDC,SAAJJ,EAAAK,EAAAC,EAAAC,SACIC,EAAAA,YACGpC,EAAAqC,WACDC,EAAOC,WACLC,EAAOC,SADbrD,UAGO,MAAAwC,EAAAxC,UAAAsD,OAAA,iBACDF,eAAeR,MAAnBhE,MAA+B2E,MAAAA,6CAG3BC,IACAC,kBAAuBC,qBAEpBC,EAAAA,gEAQTC,GAAAA,GAAAA,EAAAC,uBACF,MAAQR,IAARS,EAAAC,iBAAA,yCAQKC,EAAAA,iEAKAN,EAAM5E,0HAWTmF,6BAAA,kGAKEC,UAAAA,UAAmBV,SAAAA,cAClB5E,wCAEDyE,KAAKc,mBArBX,uEClDIC,KAAAA,oCCKYC,gBAAA,gBACPJ,gCAFTrF,KAAA0F,aAOItE,UAAOuE,QAAP,gBACKR,uFAKDS,UAAAA,gBAAAA,gBACEC,UAAQD,GAAhB5F,KAAyB8F,qBAGzB1E,UAAU2E,eAAA,WACV/F,KAAAgG,mBAA2CC,gBAG7Cd,eAAA,sEAIOe,cAAY,qEAIZA,kBAAP,SAAAC,EAAAC,8CAGOC,KAAAA,kBAAkBF,EAAAG,GAAAF,OAEhBG,QACHZ,KADGY,2BAILhC,IAAS6B,EAAW,CACfI,GAAAA,GAAAA,EACHb,GAAOc,KADJzG,KAED0G,8EAOMC,iBAAc3G,mBAKbW,gBAAL,sEAGSiG,kBAAT5G,KAAAmG,gBAGFU,wBAAU,0DAEV7G,KAAA8G,aAAA,uCAKOlD,iBAASmD,sCAGhB,KAAAC,GAAA,SAAAC,EAAAC,EAAApD,0BAKMqD,SAANC,cAMOxD,EAAQuD,EAACJ,mBACd7F,SACM2E,EAARwB,gBACa,IAAA,GAAAf,GAAM,EAAAA,EAAAgB,EAAAC,SAAAjB,EAAA,OACRgB,EAAThB,EADF,IAAAkB,IAAAxG,OAIU,MAAHE,GAAGsG,EAAApG,oBAAAJ,QACJmG,GAAAjG,YAANsG,GACA,MAAAnD,GAAA8C,GAAA/E,KAAAqF,EAAAvG,OATJ,IAAA,kBAAAsG,GAAA,CAjCG,GAAAE,GAAArD,EAAAmD,GAAApF,KAAAqF,EAAAvG,EAAA,IAAAwG,IA8CYP,EACJvD,MAAQ8D,EACb,IAAAA,EACMC,MAAAA,GAARR,GAAA/E,KAAAqF,EAAAvG,OAEQiG,IAAGnF,EAAT4F,SAAA1G,GAAA,CADF,IAAA,WAAA2G,EAAA,EAAAA,EAAAC,EAAAP,SAAAM,EAAA,CAIU,GAAAE,GAAAD,EAAAD,EACJ,IAANL,EAAAO,IAAA7G,EAAA6G,GACA,QAAAC,4CA5BA,8BATJhG,EAAAqC,WAnBGrC,EAAAiG,6BC3CFC,GAALC,SAAoB,KAAInH,GAAJ,SAAUiG,EAAAC,EAAApD,kBAE1BA,QAAA,SAAgBF,4BAO+E,GAAAwE,GAAAC,cAAAC,aAYnGC,sFCxBa,oBDQEC,gBAAA,yBAC4CC,aAAK,yBACjDC,YAAP,WAAA,MAAA,sBACK9E,EAAAxC,UAAAuH,aAAA,yBACLC,aAAA,kCALJ5I,KAAA6I,OAAAL,gBAAA,KADFM,EAAAnI,KAAAX,KAAA6I,sBAYSX,YAAA,kBADTjC,KAAAjG,KAAA6I,OAAA,kCAMJ,+BAASE,QAEDL,OE3BRN,EAAAC,cAAwB,OACtBW,OAAYT,IACbU,0BAAA,kDAED,GAAAC,GAA8BtF,EAAAxC,UAAewH,aACvCO,EAAqBvF,EAAAxC,UAAAgI,6BAErBC,EAAuBzF,EAAAxC,UAAgBuH,aACrCW,EAAoB1F,EAAOxC,UAAcoH,eAC7CJ,GAAOa,0BAA6B,WACrCrF,EAAAxC,UAAAwH,aAAAM,4BAEDtF,EAAO+E,aAAqBY,EACtB3F,EAAMxC,UAAYuH,aAAAU,EACpBzF,EAAIxC,UAAgBoH,gBAAac,EAChCE,GAAgB,MAEN,IACZpI,UAAAwH,aAAAR,EAAAhH,UAAAwH,eACIxH,UAAWgI,YAAMhB,EAAAhH,UAAAgI,sDAEtBxF,EAAOxC,UAAQoH,gBAAmB,WACnC,GAAAiB,GAAAzJ,KAAA2I,cACFc,IAAA,MAAAA,EAAAjB,kBAAAiB,EAAAjB,gBAAAxI,QDrBcoI,oBAEmCnB,EAAAC,EAAApD,kBAC1C4F,QAAAA,SAAelF,EAAOmF,cEqBeC,EAAA9I,UACjC4H,QAAO9G,gBCaZiI,OADL,UC9BIC,GAAeC,EAAYC,EAAAA,GAJjC,GAAAlJ,GAAAd,IAMMiK,KACAC,EAAWnD,EAAAoD,EAAA,SAAAC,MACIH,kBAAAA,YACEA,WAAAA,qCAGvBjI,EAAAqI,SAAAD,owIJZoDxG,EAAA0G,WAA7BC,EAA8CC,EAAAA,SAC7DC,EAAYjG,YAAAkG,UACZC,EAAYnG,YACCA,EAAOoG,8EAKRpG,+BACIA,oCACFA,OACdqG,cAG0BC,GAAlBtG,EAAO0D,IAAAA,2DAML6C,EAAAA,IAAhB,0BAEA,GAAsB/I,EAAtBgJ,IAAA,oCACIC,EAAeD,IAAnB,iCAEsB,GAANhJ,EAAAgJ,IAAM,sCACRhJ,EAAAgJ,IAAA,kCAERlG,UAAQtB,4BAAZ,6CAEqB,QAAAH,EAAAF,UACd+H,oDAGL,WAJF,IAAA,OAAAlL,KAAAmD,qHAUQgI,mCAA8B,gCAEhCC,MAAAnF,GAAAjG,sEAIwBqL,UAAhBF,KAAAA,uBAEkDG,sBAAyBvD,iBAAM,KAAkBwD,UAAlBC,KAAAA,oGAK/FxL,KAAAyL,eA5BFzL,MAAA0L,0DA+BAC,EAAsCC,EAAA5L,qKAOhC8E,WAAJ,OAAA9E,KAAAmD,uBAGQ0I,8BAAA,kBACSnC,YAAPoC,WAAoBC,eACxBC,yBAAA,0BAG2BjE,QAAnB8C,KAAAA,kEANZ1H,WAAA,QAAAnD,KAAAmD,UADFnD,KAYO8E,iFAEDmH,mDAICC,sBAAuB,kBACRnE,aAAZoE,WAAV,2CAIK1D,GAAA2D,EAAAC,EAAAvL,GAAAd,sCAEU,SAAAO,MAFV+L,GAAAC,MAGW,kBAAShM,GAAT,OAAA+L,EAHX/L,EAAAyB,EAAAwK,WAAAF,EAAA/L,OAIE0F,MAJTwG,4BAAA,SAAAlM,eAQOmM,kBAAAA,GAAqB,OAAAJ,EACG/L,EAAAyB,EAAAwK,WAAAF,EAAA/L,OACO0F,OADtC0G,GAAA,sFAKF,KAASC,IAAAA,OAAAA,qGAEL,KAAApI,GAA2CgF,iBAAAqD,IAAA,IACrCC,GAAAlJ,EAAAxC,UAAA2L,mBAFRC,EAAApJ,EAAAxC,UAAA6L,qDAWOzC,GAAAA,EAAAA,oBAA6BhG,GAAAgF,gBACxB0D,KAAMC,IAAXnM,OAAP,uIAGOoM,EAAAA,UAATH,kBAAgCD,EACvB5E,EAAAa,4BACCoE,EAAAA,sBACGvB,iBAAAA,oEAIb1D,EAASkF,4BACAC,iEAGT,MAASC,IAAAA,iBAA2BzF,sBAIpC,IACQA,GAAN,kBAAaxE,aAAb,CACOuB,GAAP2I,GAAA,GAAAC,aAAA,8DK9IOC,GAAAA,GAAiBC,GAASC,aAAuBjE,EAAAkE,eAAAC,OAAAN,iBAEpDhD,QAAYjG,EAAOiG,OAAPuD,cAAhBC,IAESC,GAAyBnG,kBAAzBmG,OAA8B,CACjCvD,GAAAA,GAAaA,GAAAA,OAAUwD,cAEpB,OADH1D,GAAAA,OAAaA,cAAAgD,GACjB,SAAA7D,EAAA6D,mDAIqBS,OAAjBD,GAACnJ,OAAD2I,GAAiBS,EAAAA,OAAAA,cAAgCN,OAC/BM,GAAAA,SAAAA,YAAD,cAIzB,sDANElM,EAAAoM,OAAAJ,cAAAP,GAMF,SAAA7D,EAAA6D,4CHXQ/D,OAFgB2E,GAAgB7J,gBAAQ8J,EAAYR,eAAA,GAAA,EAC5CtJ,IACOA,EAAOmF,OAAAA,cAAsBsE,IAC5CxD,MAAAA,UACAE,YACAC,OAAAA,QAIc,2BAEhB2D,WACAC,MAAAA,SAAJC,KAAAC,MAAA9M,QAAA+M,YAGW3M,EAAAoM,OAKLQ,SAAcC,MAAwB9G,GAAYoE,KAAZvC,EAATkE,cAA2CgB,EAAA9M,EAAAoM,OAAAW,WAAaC,IAAzFF,EAAAJ,MAAA1M,EAAAoM,UAAAY,MAAA5M,KAAAuM,UAAA,KACIM,IALsD,WAC/CvG,OAAT,wBAQFwG,EAXFC,iBAAAD,oCAqBoBnH,mBAClBmH,iCAEI,OAAApO,QAAAA,EAAAsO,MAAAA,qBAEMxE,EAAWyE,UACV/D,QAAAA,uBAEG,SAAA1B,EAAAgC,EAAA9K,GACZ,OAAmD2H,OAAKmD,EAAA9K,QAAAA,8CAMpCyN,2CAIfrD,WAAAA,GACHP,GAAaA,iBAKVuB,EAAuBtC,EACpBuC,EAAVvC,GAAA8E,MAAA,KAAAC,qCAGEW,GAAA,YAGWC,+DAOR/E,EAAAA,gBACAgF,EAAWrC,mECzEsCmB,YAAYmB,GAAA,gDAIhE7N,EAAAA,SAAyB8N,6BAEzBC,IAAJD,EAAAE,qCAIAH,IAAAA,EAAAI,eAAArL,GAAAqL,aAAA,wCAGIC,oEAEetL,uBACTkE,cACFqH,eAAAC,6FAIEL,IACEA,UAAAA,SAAmBpB,KACgBA,KAAlCsB,cAAA,6BAGD5D,aAASmB,GAAAA,eACN1E,YAAK6F,EAZhB3K,EAAAxC,UAAA6O,WAAAC,KADFT,EAAAU,YAAA3L,GAAA2L,aAgBK3K,GAAAA,YAAA,4CAUSsC,WAAZsI,cACOvG,SAAgB/B,SAAvBiC,EAAAhD,EAAAoD,iFAMGkG,aAAA,SAAAC,iBACCjD,4BADD,SAAAjD,OAAPhJ,UAAA2L,mBAAA,wGC7CFnJ,EAAAxC,UAAA2O,eAAA,SAAA7K,EAAAqL","file":"vendor-bundle-292243d411.js","sourceRoot":"..","sourcesContent":["import Symbol from './_Symbol.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nexport default getRawTag;\n","import Symbol from './_Symbol.js';\nimport getRawTag from './_getRawTag.js';\nimport objectToString from './_objectToString.js';\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nexport default baseGetTag;\n","/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\nexport default overArg;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nexport default objectToString;\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nexport default isObjectLike;\n","import overArg from './_overArg.js';\n\n/** Built-in value references. */\nvar getPrototype = overArg(Object.getPrototypeOf, Object);\n\nexport default getPrototype;\n","import baseGetTag from './_baseGetTag.js';\nimport getPrototype from './_getPrototype.js';\nimport isObjectLike from './isObjectLike.js';\n\n/** `Object#toString` result references. */\nvar objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to infer the `Object` constructor. */\nvar objectCtorString = funcToString.call(Object);\n\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */\nfunction isPlainObject(value) {\n  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n    return false;\n  }\n  var proto = getPrototype(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n  return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n    funcToString.call(Ctor) == objectCtorString;\n}\n\nexport default isPlainObject;\n","import isPlainObject from 'lodash/isPlainObject'\n\nexport default function isStatePlainEnough (a) {\n  // isPlainObject + duck type not immutable\n  if (!a) return false\n  if (typeof a !== 'object') return false\n  if (typeof a.asMutable === 'function') return false\n  if (!isPlainObject(a)) return false\n  return true\n}\n","import { REHYDRATE } from './constants'\nimport isStatePlainEnough from './utils/isStatePlainEnough'\n\nexport default function autoRehydrate (config = {}) {\n  const stateReconciler = config.stateReconciler || defaultStateReconciler\n\n  return (next) => (reducer, initialState, enhancer) => {\n    let store = next(liftReducer(reducer), initialState, enhancer)\n    return {\n      ...store,\n      replaceReducer: (reducer) => {\n        return store.replaceReducer(liftReducer(reducer))\n      }\n    }\n  }\n\n  function liftReducer (reducer) {\n    let rehydrated = false\n    let preRehydrateActions = []\n    return (state, action) => {\n      if (action.type !== REHYDRATE) {\n        if (config.log && !rehydrated) preRehydrateActions.push(action) // store pre-rehydrate actions for debugging\n        return reducer(state, action)\n      } else {\n        if (config.log && !rehydrated) logPreRehydrate(preRehydrateActions)\n        rehydrated = true\n\n        let inboundState = action.payload\n        let reducedState = reducer(state, action)\n\n        return stateReconciler(state, inboundState, reducedState, config.log)\n      }\n    }\n  }\n}\n\nfunction logPreRehydrate (preRehydrateActions) {\n  const concernedActions = preRehydrateActions.slice(1)\n  if (concernedActions.length > 0) {\n    console.log(`\n      redux-persist/autoRehydrate: %d actions were fired before rehydration completed. This can be a symptom of a race\n      condition where the rehydrate action may overwrite the previously affected state. Consider running these actions\n      after rehydration:\n    `, concernedActions.length, concernedActions)\n  }\n}\n\nfunction defaultStateReconciler (state, inboundState, reducedState, log) {\n  let newState = {...reducedState}\n\n  Object.keys(inboundState).forEach((key) => {\n    // if initialState does not have key, skip auto rehydration\n    if (!state.hasOwnProperty(key)) return\n\n    // if initial state is an object but inbound state is null/undefined, skip\n    if (typeof state[key] === 'object' && !inboundState[key]) {\n      if (log) console.log('redux-persist/autoRehydrate: sub state for key `%s` is falsy but initial state is an object, skipping autoRehydrate.', key)\n      return\n    }\n\n    // if reducer modifies substate, skip auto rehydration\n    if (state[key] !== reducedState[key]) {\n      if (log) console.log('redux-persist/autoRehydrate: sub state for key `%s` modified, skipping autoRehydrate.', key)\n      newState[key] = reducedState[key]\n      return\n    }\n\n    // otherwise take the inboundState\n    if (isStatePlainEnough(inboundState[key]) && isStatePlainEnough(state[key])) newState[key] = {...state[key], ...inboundState[key]} // shallow merge\n    else newState[key] = inboundState[key] // hard set\n\n    if (log) console.log('redux-persist/autoRehydrate: key `%s`, rehydrated to ', key, newState[key])\n  })\n  return newState\n}\n","const setImmediate = typeof global !== 'undefined' && typeof global.setImmediate !== 'undefined' ? global.setImmediate : setTimeout\n\nexport default setImmediate\n","import setImmediate from '../utils/setImmediate'\n\nlet noStorage = () => { /* noop */ return null }\nif (process.env.NODE_ENV !== 'production') {\n  noStorage = () => {\n    console.error('redux-persist asyncLocalStorage requires a global localStorage object. Either use a different storage backend or if this is a universal redux application you probably should conditionally persist like so: https://gist.github.com/rt2zz/ac9eb396793f95ff3c3b')\n    return null\n  }\n}\n\nfunction _hasStorage (storageType) {\n  if (typeof window !== 'object' || !(storageType in window)) {\n    return false\n  }\n\n  try {\n    let storage = window[storageType]\n    const testKey = `redux-persist ${storageType} test`\n    storage.setItem(testKey, 'test')\n    storage.getItem(testKey)\n    storage.removeItem(testKey)\n  } catch (e) {\n    if (process.env.NODE_ENV !== 'production') console.warn(`redux-persist ${storageType} test failed, persistence will be disabled.`)\n    return false\n  }\n  return true\n}\n\nfunction hasLocalStorage () {\n  return _hasStorage('localStorage')\n}\n\nfunction hasSessionStorage () {\n  return _hasStorage('sessionStorage')\n}\n\nfunction getStorage (type) {\n  if (type === 'local') {\n    return hasLocalStorage()\n      ? window.localStorage\n      : { getItem: noStorage, setItem: noStorage, removeItem: noStorage, getAllKeys: noStorage }\n  }\n  if (type === 'session') {\n    return hasSessionStorage()\n      ? window.sessionStorage\n      : { getItem: noStorage, setItem: noStorage, removeItem: noStorage, getAllKeys: noStorage }\n  }\n}\n\nexport default function (type, config) {\n  let storage = getStorage(type)\n  return {\n    getAllKeys: function (cb) {\n      return new Promise((resolve, reject) => {\n        try {\n          var keys = []\n          for (var i = 0; i < storage.length; i++) {\n            keys.push(storage.key(i))\n          }\n          setImmediate(() => {\n            cb && cb(null, keys)\n            resolve(keys)\n          })\n        } catch (e) {\n          cb && cb(e)\n          reject(e)\n        }\n      })\n    },\n    getItem (key, cb) {\n      return new Promise((resolve, reject) => {\n        try {\n          var s = storage.getItem(key)\n          setImmediate(() => {\n            cb && cb(null, s)\n            resolve(s)\n          })\n        } catch (e) {\n          cb && cb(e)\n          reject(e)\n        }\n      })\n    },\n    setItem (key, string, cb) {\n      return new Promise((resolve, reject) => {\n        try {\n          storage.setItem(key, string)\n          setImmediate(() => {\n            cb && cb(null)\n            resolve()\n          })\n        } catch (e) {\n          cb && cb(e)\n          reject(e)\n        }\n      })\n    },\n    removeItem (key, cb) {\n      return new Promise((resolve, reject) => {\n        try {\n          storage.removeItem(key)\n          setImmediate(() => {\n            cb && cb(null)\n            resolve()\n          })\n        } catch (e) {\n          cb && cb(e)\n          reject(e)\n        }\n      })\n    }\n  }\n}\n","import { KEY_PREFIX } from './constants'\n\nexport default function purgeStoredState (config, keys) {\n  const storage = config.storage\n  const keyPrefix = config.keyPrefix !== undefined ? config.keyPrefix : KEY_PREFIX\n\n  // basic validation\n  if (Array.isArray(config)) throw new Error('redux-persist: purgeStoredState requires config as a first argument (found array). An array of keys is the optional second argument.')\n  if (!storage) throw new Error('redux-persist: config.storage required in purgeStoredState')\n\n  if (typeof keys === 'undefined') { // if keys is not defined, purge all keys\n    return new Promise((resolve, reject) => {\n      storage.getAllKeys((err, allKeys) => {\n        if (err) {\n          if (process.env.NODE_ENV !== 'production') console.warn('redux-persist: error during purgeStoredState in storage.getAllKeys')\n          reject(err)\n        } else {\n          resolve(purgeStoredState(config, allKeys.filter((key) => key.indexOf(keyPrefix) === 0).map((key) => key.slice(keyPrefix.length))))\n        }\n      })\n    })\n  } else { // otherwise purge specified keys\n    return Promise.all(keys.map((key) => {\n      return storage.removeItem(`${keyPrefix}${key}`, warnIfRemoveError(key))\n    }))\n  }\n}\n\nfunction warnIfRemoveError (key) {\n  return function removeError (err) {\n    if (err && process.env.NODE_ENV !== 'production') { console.warn('Error storing data for key:', key, err) }\n  }\n}\n","import { KEY_PREFIX, REHYDRATE } from './constants'\nimport createAsyncLocalStorage from './defaults/asyncLocalStorage'\nimport purgeStoredState from './purgeStoredState'\nimport stringify from 'json-stringify-safe'\n\nexport default function createPersistor (store, config) {\n  // defaults\n  const serializer = config.serialize === false ? (data) => data : defaultSerializer\n  const deserializer = config.serialize === false ? (data) => data : defaultDeserializer\n  const blacklist = config.blacklist || []\n  const whitelist = config.whitelist || false\n  const transforms = config.transforms || []\n  const debounce = config.debounce || false\n  const keyPrefix = config.keyPrefix !== undefined ? config.keyPrefix : KEY_PREFIX\n\n  // pluggable state shape (e.g. immutablejs)\n  const stateInit = config._stateInit || {}\n  const stateIterator = config._stateIterator || defaultStateIterator\n  const stateGetter = config._stateGetter || defaultStateGetter\n  const stateSetter = config._stateSetter || defaultStateSetter\n\n  // storage with keys -> getAllKeys for localForage support\n  let storage = config.storage || createAsyncLocalStorage('local')\n  if (storage.keys && !storage.getAllKeys) {\n    storage.getAllKeys = storage.keys\n  }\n\n  // initialize stateful values\n  let lastState = stateInit\n  let paused = false\n  let storesToProcess = []\n  let timeIterator = null\n\n  store.subscribe(() => {\n    if (paused) return\n\n    let state = store.getState()\n\n    stateIterator(state, (subState, key) => {\n      if (!passWhitelistBlacklist(key)) return\n      if (stateGetter(lastState, key) === stateGetter(state, key)) return\n      if (storesToProcess.indexOf(key) !== -1) return\n      storesToProcess.push(key)\n    })\n\n    // time iterator (read: debounce)\n    if (timeIterator === null) {\n      timeIterator = setInterval(() => {\n        if (storesToProcess.length === 0) {\n          clearInterval(timeIterator)\n          timeIterator = null\n          return\n        }\n\n        let key = storesToProcess.shift()\n        let storageKey = createStorageKey(key)\n        let endState = transforms.reduce((subState, transformer) => transformer.in(subState, key), stateGetter(store.getState(), key))\n        if (typeof endState !== 'undefined') storage.setItem(storageKey, serializer(endState), warnIfSetError(key))\n      }, debounce)\n    }\n\n    lastState = state\n  })\n\n  function passWhitelistBlacklist (key) {\n    if (whitelist && whitelist.indexOf(key) === -1) return false\n    if (blacklist.indexOf(key) !== -1) return false\n    return true\n  }\n\n  function adhocRehydrate (incoming, options = {}) {\n    let state = {}\n    if (options.serial) {\n      stateIterator(incoming, (subState, key) => {\n        try {\n          let data = deserializer(subState)\n          let value = transforms.reduceRight((interState, transformer) => {\n            return transformer.out(interState, key)\n          }, data)\n          state = stateSetter(state, key, value)\n        } catch (err) {\n          if (process.env.NODE_ENV !== 'production') console.warn(`Error rehydrating data for key \"${key}\"`, subState, err)\n        }\n      })\n    } else state = incoming\n\n    store.dispatch(rehydrateAction(state))\n    return state\n  }\n\n  function createStorageKey (key) {\n    return `${keyPrefix}${key}`\n  }\n\n  // return `persistor`\n  return {\n    rehydrate: adhocRehydrate,\n    pause: () => { paused = true },\n    resume: () => { paused = false },\n    purge: (keys) => purgeStoredState({storage, keyPrefix}, keys)\n  }\n}\n\nfunction warnIfSetError (key) {\n  return function setError (err) {\n    if (err && process.env.NODE_ENV !== 'production') { console.warn('Error storing data for key:', key, err) }\n  }\n}\n\nfunction defaultSerializer (data) {\n  return stringify(data, null, null, (k, v) => {\n    if (process.env.NODE_ENV !== 'production') return null\n    throw new Error(`\n      redux-persist: cannot process cyclical state.\n      Consider changing your state structure to have no cycles.\n      Alternatively blacklist the corresponding reducer key.\n      Cycle encounted at key \"${k}\" with value \"${v}\".\n    `)\n  })\n}\n\nfunction defaultDeserializer (serial) {\n  return JSON.parse(serial)\n}\n\nfunction rehydrateAction (data) {\n  return {\n    type: REHYDRATE,\n    payload: data\n  }\n}\n\nfunction defaultStateIterator (collection, callback) {\n  return Object.keys(collection).forEach((key) => callback(collection[key], key))\n}\n\nfunction defaultStateGetter (state, key) {\n  return state[key]\n}\n\nfunction defaultStateSetter (state, key, value) {\n  state[key] = value\n  return state\n}\n","exports = module.exports = stringify\nexports.getSerialize = serializer\n\nfunction stringify(obj, replacer, spaces, cycleReplacer) {\n  return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces)\n}\n\nfunction serializer(replacer, cycleReplacer) {\n  var stack = [], keys = []\n\n  if (cycleReplacer == null) cycleReplacer = function(key, value) {\n    if (stack[0] === value) return \"[Circular ~]\"\n    return \"[Circular ~.\" + keys.slice(0, stack.indexOf(value)).join(\".\") + \"]\"\n  }\n\n  return function(key, value) {\n    if (stack.length > 0) {\n      var thisPos = stack.indexOf(this)\n      ~thisPos ? stack.splice(thisPos + 1) : stack.push(this)\n      ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key)\n      if (~stack.indexOf(value)) value = cycleReplacer.call(this, key, value)\n    }\n    else stack.push(value)\n\n    return replacer == null ? value : replacer.call(this, key, value)\n  }\n}\n","import { KEY_PREFIX } from './constants'\nimport createAsyncLocalStorage from './defaults/asyncLocalStorage'\n\nexport default function getStoredState (config, onComplete) {\n  let storage = config.storage || createAsyncLocalStorage('local')\n  const deserializer = config.serialize === false ? (data) => data : defaultDeserializer\n  const blacklist = config.blacklist || []\n  const whitelist = config.whitelist || false\n  const transforms = config.transforms || []\n  const keyPrefix = config.keyPrefix !== undefined ? config.keyPrefix : KEY_PREFIX\n\n  // fallback getAllKeys to `keys` if present (LocalForage compatability)\n  if (storage.keys && !storage.getAllKeys) storage = {...storage, getAllKeys: storage.keys}\n\n  let restoredState = {}\n  let completionCount = 0\n\n  storage.getAllKeys((err, allKeys) => {\n    if (err) {\n      if (process.env.NODE_ENV !== 'production') console.warn('redux-persist/getStoredState: Error in storage.getAllKeys')\n      complete(err)\n    }\n\n    let persistKeys = allKeys.filter((key) => key.indexOf(keyPrefix) === 0).map((key) => key.slice(keyPrefix.length))\n    let keysToRestore = persistKeys.filter(passWhitelistBlacklist)\n\n    let restoreCount = keysToRestore.length\n    if (restoreCount === 0) complete(null, restoredState)\n    keysToRestore.forEach((key) => {\n      storage.getItem(createStorageKey(key), (err, serialized) => {\n        if (err && process.env.NODE_ENV !== 'production') console.warn('redux-persist/getStoredState: Error restoring data for key:', key, err)\n        else restoredState[key] = rehydrate(key, serialized)\n        completionCount += 1\n        if (completionCount === restoreCount) complete(null, restoredState)\n      })\n    })\n  })\n\n  function rehydrate (key, serialized) {\n    let state = null\n\n    try {\n      let data = deserializer(serialized)\n      state = transforms.reduceRight((subState, transformer) => {\n        return transformer.out(subState, key)\n      }, data)\n    } catch (err) {\n      if (process.env.NODE_ENV !== 'production') console.warn('redux-persist/getStoredState: Error restoring data for key:', key, err)\n    }\n\n    return state\n  }\n\n  function complete (err, restoredState) {\n    onComplete(err, restoredState)\n  }\n\n  function passWhitelistBlacklist (key) {\n    if (whitelist && whitelist.indexOf(key) === -1) return false\n    if (blacklist.indexOf(key) !== -1) return false\n    return true\n  }\n\n  function createStorageKey (key) {\n    return `${keyPrefix}${key}`\n  }\n\n  if (typeof onComplete !== 'function' && !!Promise) {\n    return new Promise((resolve, reject) => {\n      onComplete = (err, restoredState) => {\n        if (err) reject(err)\n        else resolve(restoredState)\n      }\n    })\n  }\n}\n\nfunction defaultDeserializer (serial) {\n  return JSON.parse(serial)\n}\n","import { REHYDRATE } from './constants'\nimport getStoredState from './getStoredState'\nimport createPersistor from './createPersistor'\nimport setImmediate from './utils/setImmediate'\n\nexport default function persistStore (store, config = {}, onComplete) {\n  // defaults\n  // @TODO remove shouldRestore\n  const shouldRestore = !config.skipRestore\n  if (process.env.NODE_ENV !== 'production' && config.skipRestore) console.warn('redux-persist: config.skipRestore has been deprecated. If you want to skip restoration use `createPersistor` instead')\n\n  let purgeKeys = null\n\n  // create and pause persistor\n  const persistor = createPersistor(store, config)\n  persistor.pause()\n\n  // restore\n  if (shouldRestore) {\n    setImmediate(() => {\n      getStoredState(config, (err, restoredState) => {\n        if (err) {\n          complete(err)\n          return\n        }\n        // do not persist state for purgeKeys\n        if (purgeKeys) {\n          if (purgeKeys === '*') restoredState = {}\n          else purgeKeys.forEach((key) => delete restoredState[key])\n        }\n\n        store.dispatch(rehydrateAction(restoredState, err))\n        complete(err, restoredState)\n      })\n    })\n  } else setImmediate(complete)\n\n  function complete (err, restoredState) {\n    persistor.resume()\n    onComplete && onComplete(err, restoredState)\n  }\n\n  return {\n    ...persistor,\n    purge: (keys) => {\n      purgeKeys = keys || '*'\n      return persistor.purge(keys)\n    }\n  }\n}\n\nfunction rehydrateAction (payload, error = null) {\n  return {\n    type: REHYDRATE,\n    payload,\n    error\n  }\n}\n","import autoRehydrate from './autoRehydrate'\nimport createPersistor from './createPersistor'\nimport createTransform from './createTransform'\nimport getStoredState from './getStoredState'\nimport persistStore from './persistStore'\nimport purgeStoredState from './purgeStoredState'\n\n// @TODO remove in v5\nconst deprecated = (cb, cb2, cb3) => {\n  console.error('redux-persist: this method of importing storages has been removed. instead use `import { asyncLocalStorage } from \"redux-persist/storages\"`')\n  if (typeof cb === 'function') cb()\n  if (typeof cb2 === 'function') cb2()\n  if (typeof cb3 === 'function') cb3()\n}\nconst deprecatedStorage = { getAllKeys: deprecated, getItem: deprecated, setItem: deprecated, removeItem: deprecated }\nconst storages = {\n  asyncLocalStorage: deprecatedStorage,\n  asyncSessionStorage: deprecatedStorage\n}\n\nexport { autoRehydrate, createPersistor, createTransform, getStoredState, persistStore, purgeStoredState, storages }\n","function createTransform (inbound, outbound, config = {}) {\n  let whitelist = config.whitelist || null\n  let blacklist = config.blacklist || null\n\n  function whitelistBlacklistCheck (key) {\n    if (whitelist && whitelist.indexOf(key) === -1) return true\n    if (blacklist && blacklist.indexOf(key) !== -1) return true\n    return false\n  }\n\n  return {\n    in: (state, key) => !whitelistBlacklistCheck(key) && inbound ? inbound(state, key) : state,\n    out: (state, key) => !whitelistBlacklistCheck(key) && outbound ? outbound(state, key) : state\n  }\n}\n\nexport default createTransform\n"]}